---
title: "ST 558 Homework 6"
format: html
editor: visual
---

## Task 1: Conceptual Questions

1.  What is the purpose of the lapply() function? What is the equivalent purrr function?

    The lapply() function allows us to apply a function to each of the elements in a list. The equivalent purrr function is map().

2.  Suppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want to use lapply() to run the code cor(numeric_matrix, method = "kendall") on each element of the list. Write code to do this below!

    `lapply(my_list, cor, method = "kendall")`

3.  What are two advantages of using purrr functions instead of the BaseR apply family?

    The purrr functions have greater consistency between the functions than the BaseR apply family. It also has some helper functions which allow us to write compact code like `list("x", 1)` for `function(x) x[["x"]][[1]]`.

4.  What is a side-effect function?

    A function that does something, but doesn't return the modified argument (df). For instance, the print function prints some output but doesn't return the argument.

5.  Why can you name a variable sd in a function and not cause any issues with the sd function?

    The function you create has it's own temporary environment with local scope that the sd variable belongs to. The sd function belongs to the stats package environment.

## Task 2: Writing R Functions

```{r}
# Load Libraries
library(tidyverse)
```

1.  Write a basic function (call it getRMSE()) that takes in a vector of responses and a vector of predictions and outputs the RMSE. If a value is missing for the vector of responses (i.e. an NA is present), allow for additional arguments to the mean() function (elipses) that removes the NA values in the computation.

```{r}
# RMSE function: sqrt of mean of responses - predictions squared.
# Allows for additional arguments to the mean function like na.rm.
getRMSE <- function(responses, predictions, ...) {
  sqrt(mean(((responses - predictions)^2), ...))
}
```

2.  Run the following code to create some response values and predictions.

```{r}
# Code to generate random responses and predictions.
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10 * x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))
```

```{r}
# Test RMSE function on data.
getRMSE(resp, pred)
```

Repeat after manually replacing two of the response values with missing values (NA_real\_). Test your RMSE function with and without specifying the behavior to deal with missing values.

```{r}
# Set two response values to missing.
resp[13] <- NA_real_
resp[50] <- NA_real_

# Test the RMSE function without specifying the behavior to deal with missing.
getRMSE(resp, pred)
```

```{r}
# Test RMSE function while specifying behavior to deal with missing.
getRMSE(resp, pred, na.rm = TRUE)
```

3.  Write a function called getMAE() that follows the specifications of the getRMSE() function.

```{r}
# MAE function: mean of absolute error (responses - predictions).
# Allows for additional arguments to the mean function like na.rm.
getMAE <- function(responses, predictions, ...) {
  mean(abs(responses - predictions), ...)
}
```

4.  Run the following code to create some response values and predictions

```{r}
# Randomly generating responses and predictions.
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10 * x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))
```

```{r}
# Test the MAE function using the data.
getMAE(resp, pred)
```

Repeat after replacing two of the response values with missing values (NA_real\_). Test your MAE function with and without specifying behavior to deal with missing values.

```{r}
# Setting two values to NA.
resp[23] <- NA_real_
resp[60] <- NA_real_

# Testing function without dealing with missing values.
getMAE(resp, pred)
```

```{r}
# Testing function while dealing with missing values.
getMAE(resp, pred, na.rm = TRUE)
```

5.  Let's create a wrapper function that can be used to get either or both metrics returned with a single function call. Do not rewrite your above two functions, call them inside the wrapper function (we would call the getRMSE() and getMAE() functions helper functions). When returning your values, give them appropriate names.
    -   Should also check that two numeric (atomic) vectors have been passed (consider is.vector(), is.atomic(), and is.numeric()). If not, the function should stop and print an informative message.

    -   Return both metrics by default and include names. The behavior should be able to be changed using a character string of metrics to find.

```{r}
# Wrapper function for getting metrics from responses and predictions
getMetrics <- function(responses, predictions, 
                       metrics = c("RMSE", "MAE"), ...) {
  # Check conditions
  if (is.vector(responses) && is.vector(predictions)) {
    if (is.atomic(responses) && is.atomic(predictions)) {
      if (is.numeric(responses) && is.numeric(predictions)) {
        metrics_list <- list()
        # If conditions are met check for RMSE metric and get it
        if ("RMSE" %in% metrics) {
          metrics_list["RMSE"] <- getRMSE(responses, predictions, ...)
        }
        # If conditions are met check for MAE metric and get it
        if ("MAE" %in% metrics) {
          metrics_list["MAE"] <- getMAE(responses, predictions, ...)
        }
        return(metrics_list)
      }
    }
  }
  # If any of the conditions are not met then stop the function with message
  stop("Arguments must be numeric atomic vectors")
}
```

6.  Run the following code to create some response values and predictions

```{r}
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10 * x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))
```

```{r}
# Test the function using this data.
# Call for the RMSE metric.
getMetrics(resp, pred, metrics = ("RMSE"))
```

```{r}
# Call for the MAE metric.
getMetrics(resp, pred, metrics = ("MAE"))
```

```{r}
# Call for both metrics.
getMetrics(resp, pred)
```

Repeat with replacing two of the response values with missing values (NA_real\_)

```{r}
# Setting values to NA.
resp[33] <- NA_real_
resp[70] <- NA_real_

# Try without handling missing values.
getMetrics(resp, pred)
```

```{r}
# Call for RMSE metric with missing values.
getMetrics(resp, pred, metrics = c("RMSE"), na.rm = TRUE)
```

```{r}
# Call for MAE metric with missing values.
getMetrics(resp, pred, metrics = c("MAE"), na.rm = TRUE)
```

```{r}
# Call for both metrics with missing values.
getMetrics(resp, pred, metrics = c("RMSE", "MAE"), na.rm = TRUE)
```

Test function by passing it incorrect data.

```{r}
# Make data into a dataframe
data <- data.frame(resp, pred)

# Call function with incorrect data
getMetrics(data[1], data[2], metrics = c("RMSE", "MAE", na.rm = TRUE))
```

```{r}
# Make vectors character
resp <- as.character(resp)
pred <- as.character(pred)

# Call function with incorrect data
getMetrics(resp, pred, na.rm = TRUE)
```

## Task 3: Practice with purrr

```{r}
# Create a list object to work with
lm_fit1 <- lm(Sepal.Length ~ Sepal.Width + Species, data = iris)
```

1.  Pull out the coefficients list element using \$, coef(), and the pluck() function from purrr.

```{r}
lm_fit1$coefficients

coef(lm_fit1)

lm_fit1 |>
  pluck(coefficients)
```

2.  Let's fit a number of different models with the code below!

```{r}
lm_fit2 <- lm(Sepal.Length ~ Sepal.Width, data = iris)
lm_fit3 <- lm(Sepal.Length ~ Petal.Width + Sepal.Width + Species, data = iris)
lm_fit4 <- lm(Sepal.Length ~ Petal.Width + Petal.Length + Sepal.Width + Species,
data = iris)
fits <- list(lm_fit1, lm_fit2, lm_fit3, lm_fit4)
```

Now use purrr::map() function to pull out the coefficients of each model fit from the fits object.

```{r}
fits |>
  map(pluck(coefficients))
```

3.  There is a function called confint() that creates confidence intervals for the coefficients in an lm() fit. We apply that function directly to the fitted object like this:

```{r}
confint(lm_fit1)
```

Use map() to apply the confint() function to each model fit in the fits object.

```{r}
fits |> 
  map(confint)
```

4.  Next, let's create histograms of the residuals in each model fit! Run the code here to set up a 2x2 plotting window.

```{r}
# Create 2x2 plotting window
par(mfrow = c(2, 2))
```

Now, pull out the residual vectors (the resid elements of your fits) using map(). Then use the walk() function with hist to create plots.

```{r}
fits |>
  map(pluck(resid)) |>
  walk(hist)
```

5.  The names aren't good, let's try to fix that! On the list that is created from the map() function used on the resid element, use the purrr::set_names() function to give the names "fit1", "fit2", "fit3", and "fit4" to the elements.

```{r}
fits |>
  map(pluck(resid)) |>
  set_names(c("fit1", "fit2", "fit3", "fit4")) |>
  iwalk(\(Residuals, idx) hist(Residuals, main = idx))
```
