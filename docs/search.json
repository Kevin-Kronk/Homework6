[
  {
    "objectID": "Homework6.html",
    "href": "Homework6.html",
    "title": "ST 558 Homework 6",
    "section": "",
    "text": "What is the purpose of the lapply() function? What is the equivalent purrr function?\nThe lapply() function allows us to apply a function to each of the elements in a list. The equivalent purrr function is map().\nSuppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want to use lapply() to run the code cor(numeric_matrix, method = “kendall”) on each element of the list. Write code to do this below!\nlapply(my_list, cor, method = \"kendall\")\nWhat are two advantages of using purrr functions instead of the BaseR apply family?\nThe purrr functions have greater consistency between the functions than the BaseR apply family. It also has some helper functions which allow us to write compact code like list(\"x\", 1) for function(x) x[[\"x\"]][[1]].\nWhat is a side-effect function?\nA function that does something, but doesn’t return the modified argument (df). For instance, the print function prints some output but doesn’t return the argument.\nWhy can you name a variable sd in a function and not cause any issues with the sd function?\nThe function you create has it’s own temporary environment with local scope that the sd variable belongs to. The sd function belongs to the stats package environment."
  },
  {
    "objectID": "Homework6.html#task-1-conceptual-questions",
    "href": "Homework6.html#task-1-conceptual-questions",
    "title": "ST 558 Homework 6",
    "section": "",
    "text": "What is the purpose of the lapply() function? What is the equivalent purrr function?\nThe lapply() function allows us to apply a function to each of the elements in a list. The equivalent purrr function is map().\nSuppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want to use lapply() to run the code cor(numeric_matrix, method = “kendall”) on each element of the list. Write code to do this below!\nlapply(my_list, cor, method = \"kendall\")\nWhat are two advantages of using purrr functions instead of the BaseR apply family?\nThe purrr functions have greater consistency between the functions than the BaseR apply family. It also has some helper functions which allow us to write compact code like list(\"x\", 1) for function(x) x[[\"x\"]][[1]].\nWhat is a side-effect function?\nA function that does something, but doesn’t return the modified argument (df). For instance, the print function prints some output but doesn’t return the argument.\nWhy can you name a variable sd in a function and not cause any issues with the sd function?\nThe function you create has it’s own temporary environment with local scope that the sd variable belongs to. The sd function belongs to the stats package environment."
  },
  {
    "objectID": "Homework6.html#task-2-writing-r-functions",
    "href": "Homework6.html#task-2-writing-r-functions",
    "title": "ST 558 Homework 6",
    "section": "Task 2: Writing R Functions",
    "text": "Task 2: Writing R Functions\n\n# Load Libraries\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\n\nWrite a basic function (call it getRMSE()) that takes in a vector of responses and a vector of predictions and outputs the RMSE. If a value is missing for the vector of responses (i.e. an NA is present), allow for additional arguments to the mean() function (elipses) that removes the NA values in the computation.\n\n\n# RMSE function: sqrt of mean of responses - predictions squared.\n# Allows for additional arguments to the mean function like na.rm.\ngetRMSE &lt;- function(responses, predictions, ...) {\n  sqrt(mean(((responses - predictions)^2), ...))\n}\n\n\nRun the following code to create some response values and predictions.\n\n\n# Code to generate random responses and predictions.\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n\n# Test RMSE function on data.\ngetRMSE(resp, pred)\n\n[1] 0.9581677\n\n\nRepeat after manually replacing two of the response values with missing values (NA_real_). Test your RMSE function with and without specifying the behavior to deal with missing values.\n\n# Set two response values to missing.\nresp[13] &lt;- NA_real_\nresp[50] &lt;- NA_real_\n\n# Test the RMSE function without specifying the behavior to deal with missing.\ngetRMSE(resp, pred)\n\n[1] NA\n\n\n\n# Test RMSE function while specifying behavior to deal with missing.\ngetRMSE(resp, pred, na.rm = TRUE)\n\n[1] 0.9595025\n\n\n\nWrite a function called getMAE() that follows the specifications of the getRMSE() function.\n\n\n# MAE function: mean of absolute error (responses - predictions).\n# Allows for additional arguments to the mean function like na.rm.\ngetMAE &lt;- function(responses, predictions, ...) {\n  mean(abs(responses - predictions), ...)\n}\n\n\nRun the following code to create some response values and predictions\n\n\n# Randomly generating responses and predictions.\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n\n# Test the MAE function using the data.\ngetMAE(resp, pred)\n\n[1] 0.8155776\n\n\nRepeat after replacing two of the response values with missing values (NA_real_). Test your MAE function with and without specifying behavior to deal with missing values.\n\n# Setting two values to NA.\nresp[23] &lt;- NA_real_\nresp[60] &lt;- NA_real_\n\n# Testing function without dealing with missing values.\ngetMAE(resp, pred)\n\n[1] NA\n\n\n\n# Testing function while dealing with missing values.\ngetMAE(resp, pred, na.rm = TRUE)\n\n[1] 0.8088088\n\n\n\nLet’s create a wrapper function that can be used to get either or both metrics returned with a single function call. Do not rewrite your above two functions, call them inside the wrapper function (we would call the getRMSE() and getMAE() functions helper functions). When returning your values, give them appropriate names.\n\nShould also check that two numeric (atomic) vectors have been passed (consider is.vector(), is.atomic(), and is.numeric()). If not, the function should stop and print an informative message.\nReturn both metrics by default and include names. The behavior should be able to be changed using a character string of metrics to find.\n\n\n\n# Wrapper function for getting metrics from responses and predictions\ngetMetrics &lt;- function(responses, predictions, \n                       metrics = c(\"RMSE\", \"MAE\"), ...) {\n  # Check conditions\n  if (is.vector(responses) && is.vector(predictions)) {\n    if (is.atomic(responses) && is.atomic(predictions)) {\n      if (is.numeric(responses) && is.numeric(predictions)) {\n        metrics_list &lt;- list()\n        # If conditions are met check for RMSE metric and get it\n        if (\"RMSE\" %in% metrics) {\n          metrics_list[\"RMSE\"] &lt;- getRMSE(responses, predictions, ...)\n        }\n        # If conditions are met check for MAE metric and get it\n        if (\"MAE\" %in% metrics) {\n          metrics_list[\"MAE\"] &lt;- getMAE(responses, predictions, ...)\n        }\n        return(metrics_list)\n      }\n    }\n  }\n  # If any of the conditions are not met then stop the function with message\n  stop(\"Arguments must be numeric atomic vectors\")\n}\n\n\nRun the following code to create some response values and predictions\n\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n\n# Test the function using this data.\n# Call for the RMSE metric.\ngetMetrics(resp, pred, metrics = (\"RMSE\"))\n\n$RMSE\n[1] 0.9581677\n\n\n\n# Call for the MAE metric.\ngetMetrics(resp, pred, metrics = (\"MAE\"))\n\n$MAE\n[1] 0.8155776\n\n\n\n# Call for both metrics.\ngetMetrics(resp, pred)\n\n$RMSE\n[1] 0.9581677\n\n$MAE\n[1] 0.8155776\n\n\nRepeat with replacing two of the response values with missing values (NA_real_).\n\n# Setting values to NA.\nresp[33] &lt;- NA_real_\nresp[70] &lt;- NA_real_\n\n# Try without handling missing values.\ngetMetrics(resp, pred)\n\n$RMSE\n[1] NA\n\n$MAE\n[1] NA\n\n\n\n# Call for RMSE metric with missing values.\ngetMetrics(resp, pred, metrics = c(\"RMSE\"), na.rm = TRUE)\n\n$RMSE\n[1] 0.9592779\n\n\n\n# Call for MAE metric with missing values.\ngetMetrics(resp, pred, metrics = c(\"MAE\"), na.rm = TRUE)\n\n$MAE\n[1] 0.8139449\n\n\n\n# Call for both metrics with missing values.\ngetMetrics(resp, pred, metrics = c(\"RMSE\", \"MAE\"), na.rm = TRUE)\n\n$RMSE\n[1] 0.9592779\n\n$MAE\n[1] 0.8139449\n\n\nTest function by passing it incorrect data.\n\n# Make data into a dataframe\ndata &lt;- data.frame(resp, pred)\n\n# Call function with incorrect data\ngetMetrics(data[1], data[2], metrics = c(\"RMSE\", \"MAE\", na.rm = TRUE))\n\nError in getMetrics(data[1], data[2], metrics = c(\"RMSE\", \"MAE\", na.rm = TRUE)): Arguments must be numeric atomic vectors\n\n\n\n# Make vectors character\nresp &lt;- as.character(resp)\npred &lt;- as.character(pred)\n\n# Call function with incorrect data\ngetMetrics(resp, pred, na.rm = TRUE)\n\nError in getMetrics(resp, pred, na.rm = TRUE): Arguments must be numeric atomic vectors"
  },
  {
    "objectID": "Homework6.html#task-3-practice-with-purrr",
    "href": "Homework6.html#task-3-practice-with-purrr",
    "title": "ST 558 Homework 6",
    "section": "Task 3: Practice with purrr",
    "text": "Task 3: Practice with purrr\n\n# Create a list object to work with.\nlm_fit1 &lt;- lm(Sepal.Length ~ Sepal.Width + Species, data = iris)\n\n\nPull out the coefficients list element using $, coef(), and the pluck() function from purrr.\n\n\n# Three ways to get the coefficients list element.\nlm_fit1$coefficients\n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\ncoef(lm_fit1)\n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\nlm_fit1 |&gt;\n  pluck(coefficients)\n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\n\n\nLet’s fit a number of different models with the code below!\n\n\n# Model Fits.\nlm_fit2 &lt;- lm(Sepal.Length ~ Sepal.Width, data = iris)\nlm_fit3 &lt;- lm(Sepal.Length ~ Petal.Width + Sepal.Width + Species, data = iris)\nlm_fit4 &lt;- lm(Sepal.Length ~ Petal.Width + Petal.Length + Sepal.Width + Species,\ndata = iris)\nfits &lt;- list(lm_fit1, lm_fit2, lm_fit3, lm_fit4)\n\nNow use purrr::map() function to pull out the coefficients of each model fit from the fits object.\n\n# Using map and pluck to get coefficients from all fits.\nfits |&gt;\n  map(pluck(coefficients))\n\n[[1]]\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\n[[2]]\n(Intercept) Sepal.Width \n  6.5262226  -0.2233611 \n\n[[3]]\n      (Intercept)       Petal.Width       Sepal.Width Speciesversicolor \n        2.5210733         0.3715768         0.6982260         0.9881297 \n Speciesvirginica \n        1.2375878 \n\n[[4]]\n      (Intercept)       Petal.Width      Petal.Length       Sepal.Width \n        2.1712663        -0.3151552         0.8292439         0.4958889 \nSpeciesversicolor  Speciesvirginica \n       -0.7235620        -1.0234978 \n\n\n\nThere is a function called confint() that creates confidence intervals for the coefficients in an lm() fit. We apply that function directly to the fitted object like this:\n\n\n# Get confidence intervals for one fit.\nconfint(lm_fit1)\n\n                      2.5 %   97.5 %\n(Intercept)       1.5206309 2.982156\nSepal.Width       0.5933983 1.013723\nSpeciesversicolor 1.2371791 1.680307\nSpeciesvirginica  1.7491525 2.144481\n\n\nUse map() to apply the confint() function to each model fit in the fits object.\n\n# Get confidence intervals for all fits.\nfits |&gt; \n  map(confint)\n\n[[1]]\n                      2.5 %   97.5 %\n(Intercept)       1.5206309 2.982156\nSepal.Width       0.5933983 1.013723\nSpeciesversicolor 1.2371791 1.680307\nSpeciesvirginica  1.7491525 2.144481\n\n[[2]]\n                2.5 %     97.5 %\n(Intercept)  5.579865 7.47258038\nSepal.Width -0.529820 0.08309785\n\n[[3]]\n                        2.5 %    97.5 %\n(Intercept)        1.74261803 3.2995285\nPetal.Width       -0.02042746 0.7635811\nSepal.Width        0.46205710 0.9343950\nSpeciesversicolor  0.44520784 1.5310516\nSpeciesvirginica   0.46412393 2.0110518\n\n[[4]]\n                       2.5 %      97.5 %\n(Intercept)        1.6182321  2.72430044\nPetal.Width       -0.6140049 -0.01630542\nPetal.Length       0.6937939  0.96469395\nSepal.Width        0.3257653  0.66601260\nSpeciesversicolor -1.1982739 -0.24885002\nSpeciesvirginica  -1.6831329 -0.36386273\n\n\n\nNext, let’s create histograms of the residuals in each model fit! Run the code here to set up a 2x2 plotting window.\n\n\n# Create 2x2 plotting window.\npar(mfrow = c(2, 2))\n\nNow, pull out the residual vectors (the resid elements of your fits) using map(). Then use the walk() function with hist to create plots.\n\n# Get the resid elements, then use them to create histograms for each fit.\nfits |&gt;\n  map(pluck(resid)) |&gt;\n  walk(hist)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe names aren’t good, let’s try to fix that! On the list that is created from the map() function used on the resid element, use the purrr::set_names() function to give the names “fit1”, “fit2”, “fit3”, and “fit4” to the elements.\n\n\n# Make residual histograms for each fit, setting the names for each.\nfits |&gt;\n  map(pluck(resid)) |&gt;\n  set_names(c(\"fit1\", \"fit2\", \"fit3\", \"fit4\")) |&gt;\n  iwalk(\\(Residuals, idx) hist(Residuals, main = idx))"
  }
]